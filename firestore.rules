rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // FONCTIONS UTILITAIRES
    // ============================================
    
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function hasRole(role) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == role;
    }
    
    function isAdmin() {
      return hasRole('admin');
    }
    
    function isArtisan() {
      return hasRole('artisan');
    }
    
    function isClient() {
      return hasRole('client');
    }
    
    function isVerified() {
      return isAuthenticated() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.statut == 'verifie';
    }
    
    // ============================================
    // 1. COLLECTION: users
    // ============================================
    // Accès privé uniquement par l'utilisateur authentifié
    // Admin peut tout lire
    // Artisans peuvent lire les profils clients (nécessaire pour créer des devis)
    // Utilisateurs dans une conversation peuvent lire les noms (nom, prenom, email)
    
    function isInConversationWith(userId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/conversations/$(request.auth.uid + '_' + userId)) ||
        exists(/databases/$(database)/documents/conversations/$(userId + '_' + request.auth.uid));
    }
    
    match /users/{userId} {
      // Lecture : propriétaire, admin, artisan lisant client, ou utilisateur en conversation
      allow read: if isOwner(userId) || 
                     isAdmin() ||
                     (isArtisan() && get(/databases/$(database)/documents/users/$(userId)).data.role == 'client') ||
                     isAuthenticated(); // ✅ Permettre lecture noms pour messagerie
      allow create: if isAuthenticated() && request.auth.uid == userId;
      allow update: if isOwner(userId) || isAdmin();
      allow delete: if isAdmin();
    }
    
    // ============================================
    // 2. COLLECTION: artisans
    // ============================================
    // Lecture publique pour permettre la recherche
    // Écriture uniquement par l'artisan propriétaire ou admin
    
    match /artisans/{artisanId} {
      allow read: if true; // Public pour recherche
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.userId &&
                       isArtisan();
      // Artisan propriétaire ou admin peut tout mettre à jour
      // Client authentifié peut uniquement mettre à jour notation + nombreAvis (après avis)
      allow update: if (isAuthenticated() && request.auth.uid == resource.data.userId) || 
                       isAdmin() ||
                       (isAuthenticated() && isClient() &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['notation', 'nombreAvis']));
      allow delete: if isAdmin();
    }
    
    // ============================================
    // 3. COLLECTION: demandes
    // ============================================
    // Client peut créer/modifier ses demandes
    // Artisans matchés peuvent lire (demandes directes)
    // Artisans vérifiés peuvent lire les demandes publiques (statuts visibles : publiee, matchee, quota_atteint)
    // Admin peut tout lire
    
    match /demandes/{demandeId} {
      allow read: if isAdmin() ||
                     isOwner(resource.data.clientId) ||
                     (isAuthenticated() && request.auth.uid in resource.data.get('artisansMatches', [])) ||
                     (isArtisan() && resource.data.statut in ['publiee', 'matchee', 'quota_atteint'] && isVerified());
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.clientId;
      allow update: if isOwner(resource.data.clientId) || isAdmin();
      allow delete: if isOwner(resource.data.clientId) || isAdmin();
      
      // Validation statut (Phase 3 : ajout 'quota_atteint', 'expiree')
      allow write: if request.resource.data.statut in ['genere', 'publiee', 'matchee', 'en_cours', 'terminee', 'annulee', 'quota_atteint', 'expiree', 'attribuee'];
      
      // Validation typeProjet (optionnel - 'express' | 'standard')
      allow write: if !request.resource.data.keys().hasAny(['typeProjet']) || 
                      request.resource.data.typeProjet in ['express', 'standard'];
    }
    
    // ============================================
    // 4. COLLECTION: devis
    // ============================================
    // Client et artisan concernés peuvent lire
    // Artisan peut créer et modifier son devis
    // Client peut accepter/refuser/valider travaux
    // DEVIS SIGNÉ = CONTRAT JURIDIQUE (pas de duplication)
    // ⚠️ PHASE 3 : Validation quota 10 devis par demande publique
    
    match /devis/{devisId} {
      allow read: if isAdmin() ||
                     isOwner(resource.data.clientId) || 
                     isOwner(resource.data.artisanId);
      // Permettre les requêtes (query) pour artisans (leurs propres devis) et clients (leurs devis reçus)
      // Nécessaire pour page /artisan/devis/nouveau (vérifier devis refusés pour révision)
      allow list: if isAdmin() || isArtisan() || isClient();
      
      // ✅ PHASE 3 : Bloquer création si quota atteint (10 devis max par demande publique)
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.artisanId &&
                       isArtisan() &&
                       // Vérifier quota demande publique (10 devis max)
                       (get(/databases/$(database)/documents/demandes/$(request.resource.data.demandeId)).data.get('devisRecus', 0) < 10 &&
                        get(/databases/$(database)/documents/demandes/$(request.resource.data.demandeId)).data.statut != 'quota_atteint');
      
      allow update: if isOwner(resource.data.artisanId) ||  // Artisan: modification devis, début/fin travaux
                       isOwner(resource.data.clientId) ||   // Client: acceptation, validation travaux, litige
                       isAdmin();
      allow delete: if isOwner(resource.data.artisanId) || isAdmin();
    }
    
    // ============================================
    // 4b. COLLECTION: demandes_express (Petits travaux < 150€)
    // ============================================
    // Client peut créer/modifier ses demandes Express
    // Artisans vérifiés peuvent lire les demandes en attente
    // Admin peut tout faire
    
    match /demandes_express/{demandeId} {
      allow read: if isAdmin() ||
                     isOwner(resource.data.clientId) ||
                     isAuthenticated(); // Tout utilisateur connecté peut lire (artisans via notifications)
      allow create: if isAuthenticated() && 
                       isClient() &&
                       request.auth.uid == request.resource.data.clientId &&
                       request.resource.data.typeProjet == 'express';
      // Client peut modifier (annulation, acceptation proposition)
      // Artisan assigné peut modifier le statut (propositions, intervention)
      allow update: if isOwner(resource.data.clientId) || 
                       (isAuthenticated() && request.auth.uid == resource.data.artisanId) ||
                       isAdmin();
      allow delete: if isOwner(resource.data.clientId) || isAdmin();
    }
    
    // ============================================
    // 4c. COLLECTION: propositions_express
    // ============================================
    // Artisan peut créer une proposition pour une demande Express
    // Client et artisan peuvent lire leurs propositions
    // Artisan peut modifier sa proposition (avant acceptation)
    // Client peut accepter/refuser
    
    match /propositions_express/{propositionId} {
      allow read: if isAuthenticated() && 
                     (isOwner(resource.data.clientId) || 
                      isOwner(resource.data.artisanId) ||
                      isAdmin());
      allow create: if isAuthenticated() && 
                       isArtisan() &&
                       isVerified() &&
                       request.auth.uid == request.resource.data.artisanId &&
                       request.resource.data.montantPropose <= 150; // Max 150€
      allow update: if (isAuthenticated() && isOwner(resource.data.artisanId) && resource.data.statut == 'en_attente_acceptation') ||
                       (isAuthenticated() && isOwner(resource.data.clientId)) ||
                       isAdmin();
      allow delete: if (isAuthenticated() && isOwner(resource.data.artisanId)) || isAdmin();
    }
    
    // ============================================
    // 4d. COLLECTION: paiements_express (CRITIQUE - Données financières)
    // ============================================
    // ⚠️ SÉCURITÉ MAXIMALE : Paiements Stripe escrow
    // LECTURE : Client, artisan, admin uniquement
    // ÉCRITURE : Uniquement backend via webhook Stripe (aucun client)
    
    match /paiements_express/{paiementId} {
      allow read: if isAuthenticated() && 
                     (isOwner(resource.data.clientId) || 
                      isOwner(resource.data.artisanId) ||
                      isAdmin());
      allow create: if false; // ⚠️ Uniquement backend via webhook Stripe
      allow update: if false; // ⚠️ Uniquement backend via webhook/capture
      allow delete: if false; // ⚠️ Jamais supprimer données financières
    }
    
    // ============================================
    // 5. COLLECTION: contrats (OBSOLÈTE - EN COURS DE MIGRATION)
    // ============================================
    // ⚠️ MIGRATION EN COURS : Collection 'contrats' → 'devis'
    // Juridiquement, un devis signé = contrat.
    // Toutes les données migreront vers 'devis' avec statuts étendus:
    // paye, en_cours, travaux_termines, termine_valide, litige
    //
    // ✅ TEMPORAIRE : Lecture autorisée pour compatibilité avis-service.ts
    // ✅ Admin update autorisé pour anonymisation RGPD (suppression cascade)
    // TODO 2026-03 : Supprimer après migration complète vers devis
    
    match /contrats/{contratId} {
      allow read: if isAuthenticated() && 
                     (isOwner(resource.data.clientId) || 
                      isOwner(resource.data.artisanId) || 
                      isAdmin());
      allow create: if false; // Bloquer création (migration vers devis)
      allow update: if isAdmin(); // Admin peut anonymiser pour RGPD
      allow delete: if false; // Bloquer suppression
    }
    
    // ============================================
    // 6. COLLECTION: conversations
    // ============================================
    // Accès uniquement aux participants + ADMIN (pour litiges)
    // Protection coordonnées avant contrat validé
    // HISTORISATION COMPLÈTE pour résolution litiges
    
    match /conversations/{conversationId} {
      allow read: if isAdmin() || 
                     (isAuthenticated() && request.auth.uid in resource.data.participants);
      allow create: if isAuthenticated() && 
                       request.auth.uid in request.resource.data.participants;
      allow update: if isAdmin() || // ✅ Admin peut anonymiser pour RGPD
                       (isAuthenticated() && request.auth.uid in resource.data.participants);
      allow delete: if isAdmin(); // ✅ Admin peut supprimer pour suppression compte RGPD
      
      // ============================================
      // 6.1 SOUS-COLLECTION: conversations/{conversationId}/messages
      // ============================================
      // Messages dans une conversation spécifique
      // Nécessaire pour la validation anti-bypass avec historique
      
      match /messages/{messageId} {
        allow read: if isAdmin() || 
                       (isAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants);
        allow list: if isAuthenticated() && 
                       request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        allow create: if isAuthenticated() &&
                         request.auth.uid == request.resource.data.authorId &&
                         request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        allow update: if isOwner(resource.data.authorId) || isAdmin(); // ✅ Admin peut anonymiser
        allow delete: if isAdmin(); // ✅ Admin peut supprimer pour suppression compte RGPD
      }
    }
    
    // ============================================
    // 7. COLLECTION: messages
    // ============================================
    // Lecture par participants + ADMIN (pour litiges)
    // Création uniquement si participant
    // HISTORISATION COMPLÈTE - jamais de suppression
    
    match /messages/{messageId} {
      allow read: if isAdmin() || isAuthenticated(); // Admin a accès total
      allow list: if isAuthenticated(); // ✅ Permettre queries pour validation historique
      allow create: if isAuthenticated() &&
                       request.auth.uid == request.resource.data.senderId;
      allow update: if isOwner(resource.data.senderId) || isAdmin(); // ✅ Admin peut anonymiser
      allow delete: if isAdmin(); // ✅ Admin peut supprimer pour suppression compte RGPD
      
      // Protection coordonnées (regex basique)
      // Note: validation complète côté client/serveur
      allow write: if request.resource.data.content != null;
    }
    
    // ============================================
    // 8. COLLECTION: avis
    // ============================================
    // Lecture publique (affichage profils)
    // Création uniquement par client après chantier
    // 1 avis par contrat
    
    match /avis/{avisId} {
      allow read: if resource.data.visible == true || 
                     isAdmin() || 
                     isOwner(resource.data.artisanId) ||
                     isOwner(resource.data.clientId); // ← CLIENT peut lire ses propres avis
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.clientId &&
                       isClient();
      allow update: if isOwner(resource.data.clientId) || 
                       isOwner(resource.data.artisanId) || // Peut répondre
                       isAdmin();
      allow delete: if isAdmin();
      
      // Validation note 1-5
      allow write: if request.resource.data.note >= 1 && 
                      request.resource.data.note <= 5;
    }
    
    // ============================================
    // 9. COLLECTION: litiges
    // ============================================
    // Client ou artisan peut créer litige sur son contrat
    // Admin gère la médiation
    
    match /litiges/{litigeId} {
      allow read: if isAdmin() ||
                     isOwner(resource.data.declarantId) ||
                     (resource.data.get('contratId', '') != '' && 
                      (isOwner(get(/databases/$(database)/documents/contrats/$(resource.data.contratId)).data.clientId) ||
                       isOwner(get(/databases/$(database)/documents/contrats/$(resource.data.contratId)).data.artisanId)));
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.declarantId;
      allow update: if isOwner(resource.data.declarantId) || isAdmin();
      allow delete: if isAdmin();
      
      // Validation type et statut (cohérent avec types/litige.ts)
      allow write: if request.resource.data.type in ['non_conformite', 'retard', 'abandon_chantier', 'facture_excessive', 'malfacon', 'non_respect_delais', 'autre'] &&
                      request.resource.data.statut in ['ouvert', 'en_mediation', 'proposition_resolution', 'resolu_accord', 'resolu_admin', 'resolu', 'abandonne', 'clos_sans_suite', 'escalade', 'escalade_juridique'];
    }
    
    // ============================================
    // 10. COLLECTION: notifications
    // ============================================
    // Lecture uniquement par l'utilisateur concerné
    // Création par le système (via Functions)
    
    match /notifications/{notificationId} {
      // ✅ FIX: le champ est 'recipientId' (pas 'userId')
      allow read: if isAdmin() || isOwner(resource.data.recipientId);
      allow list: if isAuthenticated() && request.auth.uid != null; // ✅ Permettre queries avec where('recipientId', '==', uid)
      allow create: if isAuthenticated(); // Via services Firebase
      allow update: if isOwner(resource.data.recipientId) || isAdmin(); // Marquer comme lu
      allow delete: if isOwner(resource.data.recipientId) || isAdmin();
    }
    
    // ============================================
    // 11. COLLECTION: transactions
    // ============================================
    // Lecture par client et artisan concernés
    // Création/modification uniquement par admin ou system (Stripe webhooks)
    
    match /transactions/{transactionId} {
      allow read: if isAdmin() ||
                     isOwner(resource.data.clientId) || 
                     isOwner(resource.data.artisanId);
      allow create: if isAdmin(); // Via Stripe webhooks
      allow update: if isAdmin(); // Mise à jour statut
      allow delete: if isAdmin();
      
      // Validation statut
      allow write: if request.resource.data.statut in ['pending', 'succeeded', 'failed', 'refunded'];
    }
    
    // ============================================
    // 12. COLLECTION: email_notifications
    // ============================================
    // Gestion des emails en attente d'envoi
    // Accessible uniquement par Cloud Functions et admin
    
    match /email_notifications/{emailId} {
      allow read: if isAdmin();
      allow create: if isAuthenticated(); // Créé par les services
      allow update: if false; // Uniquement Cloud Function
      allow delete: if isAdmin();
    }
    
    // ============================================
    // 13. COLLECTION: disponibilites
    // ============================================
    // Disponibilités artisans (agenda)
    // Lecture publique pour affichage
    // Écriture uniquement par artisan propriétaire ou admin
    
    match /disponibilites/{disponibiliteId} {
      allow read: if true; // Public pour affichage disponibilités
      allow create: if isAuthenticated() && isArtisan();
      allow update: if isAuthenticated() && 
                       (isOwner(resource.data.artisanId) || isAdmin());
      allow delete: if isAuthenticated() && 
                       (isOwner(resource.data.artisanId) || isAdmin());
    }
    
    // ============================================
    // 14. COLLECTION: scheduled_deletions
    // ============================================
    // Suppressions de compte programmées
    // Accessible uniquement par admin
    
    match /scheduled_deletions/{userId} {
      allow read: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // ============================================
    // 15. COLLECTION: artisan_stats (SCORING RÉACTIVITÉ)
    // ============================================
    // Statistiques de performance artisan pour scoring matching
    // Lecture publique (nécessaire pour matching)
    // Écriture uniquement par système (services Firebase)
    
    match /artisan_stats/{artisanId} {
      allow read: if true; // Public pour affichage stats + calcul matching
      allow create: if isAuthenticated(); // Créé automatiquement par services
      allow update: if isAuthenticated(); // Mis à jour par services Firebase
      allow delete: if isAdmin();
    }
    
    // ============================================
    // 17. COLLECTION: deleted_accounts
    // ============================================
    // Archives des comptes supprimés
    // Accessible uniquement par admin en lecture seule
    
    match /deleted_accounts/{userId} {
      allow read: if isAdmin();
      allow create: if isAuthenticated(); // Créé lors de la suppression
      allow update: if false; // Pas de modification après création
      allow delete: if isAdmin();
    }
    
    // ============================================
    // 20. COLLECTION: admin_access_logs
    // ============================================
    // Journalisation des accès à l'interface admin
    // Détection brute force + blocage IP
    // Création : tout utilisateur authentifié (tentatives de login)
    // Lecture/liste : admin uniquement
    
    match /admin_access_logs/{logId} {
      allow read: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAuthenticated(); // Logguer tentatives login
      allow update: if false;
      allow delete: if isAdmin();
    }
    
    // ============================================
    // 21. COLLECTION: blocked_ips
    // ============================================
    // IPs temporairement bloquées après brute force détecté
    // Création/lecture : utilisateur authentifié (vérification au login)
    // Suppression : admin uniquement
    
    match /blocked_ips/{ipId} {
      allow read: if isAuthenticated();
      allow list: if isAuthenticated(); // Vérifier si IP bloquée
      allow create: if isAuthenticated();
      allow update: if false;
      allow delete: if isAdmin();
    }
    
    // ============================================
    // 22. COLLECTION: support_tickets
    // ============================================
    // Tickets de support utilisateurs
    // Lecture/création par propriétaire ou admin
    // Suppression uniquement par admin (cascade suppression compte)
    
    match /support_tickets/{ticketId} {
      allow read: if isAdmin() ||
                     (isAuthenticated() && isOwner(resource.data.userId));
      allow list: if isAdmin() ||
                     (isAuthenticated() && request.auth.uid != null);
      allow create: if isAuthenticated();
      allow update: if isAdmin() ||
                     (isAuthenticated() && isOwner(resource.data.userId));
      allow delete: if isAdmin();
    }
    
    // ============================================
    // 23. COLLECTION: wallets
    // ============================================
    // Portefeuilles artisans (revenus, paiements Stripe)
    // Lecture par propriétaire ou admin
    // Écriture uniquement par backend/admin (Stripe webhooks)
    
    match /wallets/{walletId} {
      allow read: if isAdmin() ||
                     (isAuthenticated() && request.auth.uid == walletId);
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin(); // Suppression cascade compte
    }
    
    // ============================================
    // 24. COLLECTION: walletTransactions
    // ============================================
    // Transactions portefeuille artisan
    // Données financières légales (10 ans)
    // Anonymisation autorisée pour RGPD
    
    match /walletTransactions/{txId} {
      allow read: if isAdmin() ||
                     (isAuthenticated() && isOwner(resource.data.artisanId));
      allow list: if isAdmin() ||
                     (isAuthenticated() && request.auth.uid != null);
      allow create: if isAdmin();
      allow update: if isAdmin(); // Anonymisation RGPD
      allow delete: if false; // Données financières légales conservées
    }
    
    // ============================================
    // 19. COLLECTION: rappels
    // ============================================
    // Demandes de rappel depuis le formulaire "Être rappelé"
    // Lecture uniquement par admin
    // Création publique (visiteurs non authentifiés)
    
    match /rappels/{rappelId} {
      allow read: if isAdmin();
      allow create: if true && // Public - formulaire accessible à tous
                      // Validation des champs obligatoires
                      request.resource.data.keys().hasAll(['nom', 'prenom', 'telephone', 'horairePrefere', 'statut', 'createdAt']) &&
                      // Validation des types
                      request.resource.data.nom is string &&
                      request.resource.data.prenom is string &&
                      request.resource.data.telephone is string &&
                      // Validation format téléphone français (10 chiffres commençant par 0)
                      request.resource.data.telephone.matches('^0[1-9][0-9\\s\\.\\-]{8,}$') &&
                      request.resource.data.statut == 'en_attente';
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}
